<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>期中考統整｜CJL's Notes WebSite</title>
    <link rel="stylesheet" href="../../css/sidebar.css">
    <link rel="stylesheet" href="../../css/main.css">
    <link rel="icon" href="../../img/notes2.png" type="image/x-icon">
    <style>
        span {
            background-color: yellow;
        }


        table {
            font-family: 'Oswald', sans-serif;
            border-collapse: collapse;

        }

        th {
            background-color: #009879;
            color: #ffffff;
            width: 20vw;
            height: 75px;
        }

        td {
            background-color: #ffffff;
            width: 6vw;
            height: 35px;
            text-align: center;
        }

        tr {
            border-bottom: 1px solid #dddddd;
        }

        tr:last-of-type {
            border-bottom: 2px solid #009879;
        }

        tr:nth-of-type(even) td {
            background-color: #f3f3f3;
        }
    </style>

</head>

<body>
    <!-- The sidebar -->
    <div class="sidebar">
        <p><a href="../../index.html"><img class="img" src="../../img/notes.png">&nbsp&nbsp陳杰龍的筆記網站</a></p>
        <a href="../../index.html"><img class="img" src="../../img/home.png">&nbsp&nbsp主頁</a>
        <a href="../../archives.html"><img class="img" src="../../img/categories.png">&nbsp&nbsp歸檔</a>
        <a class="active" href="../../categories.html"><img class="img" src="../../img/file.png">&nbsp&nbsp分類</a>
        <a href="../../others.html"><img class="img" src="../../img/others.png">&nbsp&nbsp其他</a>
        <a href="../../about.html"><img class="img" src="../../img/self.png">&nbsp&nbsp關於我</a>
    </div>

    <!-- Page content -->


    <div class="content">

        <div id="top">&nbsp&nbsp</div>



        <div style="width: 100%; text-align: center; ">
            <p>
            <h2><a href="OS.html"><img style="vertical-align: bottom	;" src="../../img/Previouspage.png"></a>&nbsp期中考統整
            </h2>
            </p>


        </div>

        <br>

        <div
            style=" width: 60%; text-align: left; margin-left: 20%; border-left-style: solid; padding-left: 30px;border-width:2px; border-color: rgb(192, 6, 167,0.5); ">

            <h4>記憶體管理：簡易系統</h4>
            <ul>
                <li>整個電腦系統的效能和兩項因素直接相關
                    <ul>
                        <li>可用的記憶體空間</li>
                        <li>系統在處理工作時，是否以最有效率的方式使用記憶體</li>
                    </ul>
                </li>
                <li><span>四種記憶體配置法</span>
                    <ul>
                        <li><span>單一使用者連續式架構</span>(Single-User Contiguous Scheme)
                            <ul>
                                <li>記憶體管理器將待處理的程式「<span>整個</span>」載入記憶體，並安排「<span>連續</span>」的記憶體空間，以滿足該程式的記憶體需求
                                </li>
                                <li>如果程式對記憶體的需求超過系統能夠提供的範圍，該程式便無法執行</li>
                                <img width="200px" src="img/1.PNG">
                                <li>問題
                                    <ul>
                                        <li>只能處理一件事情，無法支援<span>多元程式</span>(Multiprogramming)</li>
                                        <li>1940~1950 主要用於研究機構，<span>商界無法接受這種電腦--成本效益太差</span></li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li><span>固定分割</span>(Fixed Partition)
                            <ul>
                                <li>又稱<span>靜態分割</span>(Static Partition)</li>
                                <li>主記憶體被分割成很多個<span>固定大小的分割區</span>，每一個<span>分割區配置給一個工作</span>(Job)，<span>不等於平均</span>
                                </li>
                                <li>每一個分割區的大小，在電腦開機時就已經固定</li>
                                <li>想要更改分割區大小，需關機更改組態再開機</li>
                                <li>記憶體內可以同時保存許多程式</li>
                                <li>程式還是必須「<span>整個</span>」載入，配置「<span>連續</span>」的記憶體空間</li>
                                <li><span>缺點</span>
                                    <ul>
                                        <li>大型工作不易獲得記憶體分割
                                            <ul>
                                                <li>如果目前可用記憶體分割區太小，而較大的分割區都已遭占用，大型工作就必須等待
                                                </li>
                                                <li>如果工作大於系統最大分割區的大小，該工作就完全沒有機會執行
                                                </li>
                                            </ul>
                                        </li>
                                        <li><span>內部碎塊</span>（Internal Fragmentation）
                                            <ul>
                                                <li>因固定分割而產生分割區內閒置空間的現象</li>

                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <img width="600px" src="img/2.PNG">

                            </ul>
                        </li>
                        <li><span>動態分割</span>(Dynamic Partition)
                            <ul>
                                <li>每項工作可以配置到連續的記憶體區塊
                                </li>
                                <li>只會配置所要求的記憶體空間，不多也不少
                                </li>
                                <li><span>外部碎塊</span>（External Fragmentation）
                                    <ul>
                                        <li>記憶體分割區之間產生的間隙</li>
                                    </ul>
                                </li>
                                <img width="800px" src="img/3.PNG">
                                <img width="800px" src="img/4.PNG">
                            </ul>
                        </li>
                        <li><span>記憶體分割區配置策略</span>
                            <ul>
                                <li>先適記憶體配置（First-Fit Memory Allocation）
                                    <ul>
                                        <li>速度快、利用率低</li>
                                    </ul>
                                    <img width="800px" src="img/5.PNG">
                                </li>
                                <li>最適記憶體配置（Best-Fit Memory Allocation）
                                    <ul>
                                        <li>速度慢、利用率高</li>
                                    </ul>
                                    <img width="800px" src="img/6.PNG">
                                </li>
                            </ul>
                        </li>
                        <li>可重新定址的動態分割(Relocatable Dynamic Partiton)</li>

                    </ul>

                </li>
            </ul>
            <h4>處理器管理</h4>
            <ul>
                <li><span>工作（Job）/程式（Program）</span>
                    <ul>
                        <li>由使用者提出，要求系統處理的一個工作單元
                        </li>
                        <li>程式是一個被動的單元
                        </li>
                    </ul>
                </li>
                <li><span>行程（Process）/作業（Task）</span>
                    <ul>
                        <li>一個會向系統索取各種資源的主動項目</li>
                        <li>正在執行中的程式稱為行程
                        </li>
                    </ul>
                </li>
                <li>執行緒（Thread）
                    <ul>
                        <li>一個行程是由多個執行緒所組成的</li>
                        <li>可以獨立於其父行程
                        </li>
                    </ul>
                </li>
                <li><span>插斷(中斷)</span> Interrupt
                    <ul>
                        <li>CPU暫停目前的行程，轉換到另一件<span>優先順序(Priority)</span>較高的工作，叫做<span>環境切換</span>(Context Switch)</li>
                    </ul>
                </li>
                <li>排程次級管理器
                    <ul>
                        <li>工作排程器（Job Scheduler）
                            <ul>
                                <li>高階排程器 (High-Level Scheduler)
                                </li>
                                <li>負責工作的排程
                                </li>
                            </ul>
                        </li>
                        <li>行程排程器（Process Scheduler）
                            <ul>
                                <li>低階排程器 (Low-Level Scheduler)
                                </li>
                                <li>負責行程的排程
                                </li>
                                <li>負責安排CPU的時間，為就緒佇列中 (Ready Queue) 的工作執行它們的行程</li>
                                <li>行程排程器利用兩種常見的週期進行排程
                                    <ul>
                                        <li>CPU週期（CPU Cycle）
                                            <ul>
                                                <li>利用CPU執行計算工作
                                                </li>
                                            </ul>
                                        </li>
                                        <li>I/O週期（I/O Cycle）
                                            <ul>
                                                <li>利用I/O裝置進行輸出/輸入
                                                </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li><span>I/O-Bound</span>
                                    <ul>
                                        <li>CPU週期比較短而I/O週期比較長</li>
                                        <li>大部分的時間都在做I/O，很少用到CPU</li>

                                    </ul>
                                </li>
                                <li><span>CPU-Bound</span>
                                    <ul>
                                        <li>CPU週期比較長而I/O週期比較短
                                        </li>
                                        <li>大部分的時間都在計算，很少進行 I/O
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                    </ul>
                <li><span>排程策略</span>(Scheduling Policy) <br>下列有一些點是<span>互相矛盾</span>的
                    <ul>
                        <li>產出率最大化 (Maximize Throughput)
                        </li>
                        <li>反應時間最小化 (Minimize Response Time)
                        </li>
                        <li>回轉時間最小化 (Minimize Turnaround Time)
                        </li>
                        <li>等待時間最小化 (Minimize Waiting Time)
                        </li>
                        <li>CPU 效率最大化 (Maximize CPU Efficiency)
                        </li>
                        <li>公平 (Fairness) 對待每一件工作
                        </li>
                    </ul>
                </li>
                <li><span>強占式排程策略</span>(Preemptive Scheduling Policy)
                    <ul>
                        <li>插斷目前正在執行中的行程，將CPU收回並轉而配置給另一個行程
                        </li>
                    </ul>
                </li>
                <li><span>非強占式排程策略</span>(Nonpreemptive Scheduling Policy)
                    <ul>
                        <li>不主動收回 CPU
                        </li>
                    </ul>
                </li>
                </li>
                <li><span>ATT(Average Turnaround Time): ∑(finishTime−arrivalTime)/N</span></li>
                <li><span>AWT(Average Waiting Time): ∑(startTime−arrivalTime)/N</span></li>
                <li><span>排程演算法</span>
                    <ul>
                        <li>先來先服務 (First-Come, First-Served; <span>FCFS</span>)
                            <ul>
                                <li>依據工作抵達的時間進行排程，愈早到達的，排在愈前面
                                </li>
                                <li><span>非強占式排程演算法</span>
                                </li>
                                <li>採用先進先出 (FIFO) 佇列
                                </li>
                                <li><span>回轉時間(Turnaround Time) 無法預測</span>
                                </li>
                                <li>Job A => 15 ms<br>
                                    Job B => 2 ms<br>
                                    Job C => 1 ms
                                </li>
                                <img width="500px" src="img/7.PNG">
                                <li>ATT：(15-0)+(17-0)+(18-0)/3 = 16.67<br>AWT：(0-0)+(15-0)+(17-0)/3 = 10.67</li>
                                <img width="500px" src="img/8.PNG">
                                <li>ATT：(1-0)+(3-0)+(18-0)/3 = 7.3<br>AWT：(0-0)+(1-0)+(3-0)/3 = 1.33</li>
                            </ul>
                        </li>
                        <li>短的工作優先［Shortest Job Next (<span>SJN</span>)；又名Shortest-Job First (<span>SJF</span>) ］
                            <ul>
                                <li>依據CPU週期的長度最短的先進行排程 </li>
                                <li><span>非強占式排程演算法</span>
                                </li>
                                <li>不適合互動式系統
                                </li>
                                <li>批次系統在執行工作之前，會先對工作的CPU 週期長度<span>提出預估</span>
                                </li>
                                <li>arrivalTime : time 0<br>
                                    Job A => 5<br>
                                    Job B => 2<br>
                                    Job C => 6<br>
                                    Job D => 4
                                </li>
                                <img width="500px" src="img/9.PNG">
                                <li>ATT：(2-0)+(6-0)+(11-0)+(17-0)/4 = 9.0<br>AWT：(0-0)+(2-0)+(6-0)+(11-0)/4 = 4.75</li>
                            </ul>
                        </li>
                        <li>優先順序排程 (Priority Scheduling)/ 權限優先法
                            <ul>
                                <li>非強占式演算法</li>
                                <li><span>優先順序排程優先處理優先權較高的工作</span></li>
                                <li>優先順序排程也有強占式版本
                                </li>
                                <table border="1">
                                    <tr>
                                        <td>Process</td>
                                        <td>Running time</td>
                                        <td>Priority</td>
                                    </tr>
                                    <tr>
                                        <td>P1</td>
                                        <td>6</td>
                                        <td>2</td>
                                    </tr>
                                    <tr>
                                        <td>P2</td>
                                        <td>12</td>
                                        <td>4</td>
                                    </tr>
                                    <tr>
                                        <td>P3</td>
                                        <td>1</td>
                                        <td>5</td>
                                    </tr>
                                    <tr>
                                        <td>P4</td>
                                        <td>3</td>
                                        <td>1</td>
                                    </tr>
                                    <tr>
                                        <td>P5</td>
                                        <td>4</td>
                                        <td>3</td>
                                    </tr>
                                </table>
                                <img width="500px" src="img/10.PNG">
                                <li>ATT：(3-0)+(9-0)+(13-0)+(25-0)+(26-0)/5 = 15.2<br>AWT：(0-0)+(3-0)+(9-0)+(13-0)+(25-0)/5 = 10.0</li>
                            </ul>
                        </li>   
                        <li>最短餘時優先 (Shortest Remaining Time, <span>SRT</span>)
                            <ul>
                                <li><span>SJN 演算法的強占式版本</span></li>
                                <li>將處理器配置給目前就緒佇列中最接近完成的工作</li>
                                <li>一旦就緒佇列中出現了剩餘時間更短的工作，就立即將處理器從目前執行中的工作，轉而配置給新進的工作</li>
                                <table border="1">
                                    <tr>
                                        <td>Process</td>
                                        <td>Running time</td>
                                        <td>Arrival Time</td>
                                    </tr>
                                    <tr>
                                        <td>Job A</td>
                                        <td>6</td>
                                        <td>0</td>
                                    </tr>
                                    <tr>
                                        <td>Job B</td>
                                        <td>3</td>
                                        <td>1</td>
                                    </tr>
                                    <tr>
                                        <td>Job C</td>
                                        <td>1</td>
                                        <td>2</td>
                                    </tr>
                                    <tr>
                                        <td>Job D</td>
                                        <td>4</td>
                                        <td>3</td>
                                    </tr>
                                    
                                </table>
                                <img width="600px" src="img/11.PNG">
                                <li>ATT：(14-0)+(5-1)+(3-2)+(9-3)/4 = 6.25<br>AWT：(0-0+9-1)+(1-1+3-2)+(2-2)+(5-3)/4 = 2.75</li>
                            </ul>
                        </li>
                        <li>循環排程 (Round Robin, RR)
                            <ul>
                                <li><span>強占式排程演算法</span>
                                </li>
                                <li>容易實施，而且具有良好的公平性
                                </li>
                                <li>排程時不考慮工作的特性
                                </li>
                                <li>每一件工作輪流使用CPU，每次以一個時間單位為期限，時間到了就換下一件工作
                                </li>
                                <li><span>時間配額 (Time Quantum)</span>
                                </li>
                                <li>適當的配額，有兩個通用的法則：
                                    <ul>
                                        <li>配額時間長度需滿足80%的CPU週期，在一個時間配額內執行完畢</li>
                                        <li>時間配額長度應該比執行一次環境切換所需時間長100倍</li>
                                    </ul>
                                </li>
                                <table border="1">
                                    <tr>
                                        <td>Process</td>
                                        <td>Running time</td>
                                        <td>Arrival Time</td>
                                        <td >Time Quantum</td>
                                    </tr>
                                    <tr>
                                        <td>Job A</td>
                                        <td>8</td>
                                        <td>0</td>
                                        <td rowspan="4">4</td>
                                    </tr>
                                    <tr>
                                        <td>Job B</td>
                                        <td>4</td>
                                        <td>1</td>
                                    </tr>
                                    <tr>
                                        <td>Job C</td>
                                        <td>9</td>
                                        <td>2</td>
                                    </tr>
                                    <tr>
                                        <td>Job D</td>
                                        <td>5</td>
                                        <td>3</td>
                                    </tr>     
                                </table>
                                <img width="600px" src="img/12.PNG">
                                <li>ATT：(20-0)+(8-1)+(26-2)+(25-3)/4 = 18.25<br>AWT：(0-0+16-4)+(4-1)+(8-2+20-12+25-24)+(12-3+24-16)/4 = 11.75</li>
                            </ul>
                        </li>
                        <li>多層次佇列 (Multiple-Level Queue)
                        </li>
                        <li>工作如何在不同佇列中移動
                            <ul>
                                <li>禁止工作在佇列間移動
                                    <ul>
                                        <li>最簡單的策略
                                        </li>
                                    </ul>
                                </li>
                                <li>允許工作在佇列間移動
                                    <ul>
                                        <li>必須制定一套調整工作優先順序的策略

                                        </li>
                                    </ul>
                                </li>
                                <li>每一層佇列的時間配額不同
                                    <ul>
                                        <li>允許工作在不同層級的佇列間移動，而且愈下層的佇列時間配額愈長

                                        </li>
                                    </ul>
                                </li>
                                <li>時間加級
                                    <ul>
                                        <li>允許工作在佇列間移動，下層佇列中等待超過一定時間的工作，將會被往上提升一個層級</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>最近期限優先 (Earliest Deadline First, EDF)
                            <ul>
                                <li>也稱為<span>動態優先權演算法</span></li>
                                <li><span>強占式排程演算法</span></li>
                                <li>主要目的是讓所有工作都能夠在各自的期限之前執行完畢
                                </li>
                                <table border="1">
                                    <tr>
                                        <td>Process</td>
                                        <td>Running time</td>
                                        <td>Arrival Time</td>
                                        <td>Deadline</td>
                                        
                                    </tr>
                                    <tr>
                                        <td>Job A</td>
                                        <td>3</td>
                                        <td>0</td>
                                        <td>6</td>
                                        
                                    </tr>
                                    <tr>
                                        <td>Job B</td>
                                        <td>1</td>
                                        <td>1</td>
                                        <td>2</td>
                                    </tr>
                                    <tr>
                                        <td>Job C</td>
                                        <td>5</td>
                                        <td>2</td>
                                        <td>10</td>
                                    </tr>
                                    <tr>
                                        <td>Job D</td>
                                        <td>2</td>
                                        <td>3</td>
                                        <td>8</td>
                                    </tr>     
                                    <tr>
                                        <td>Job E</td>
                                        <td>2</td>
                                        <td>3</td>
                                        <td>8</td>
                                    </tr> 
                                    <tr>
                                        <td>Job F</td>
                                        <td>5</td>
                                        <td>5</td>
                                        <td>15</td>
                                    </tr> 
                                </table>
                                <img width="600px" src="img/13.PNG">
                            </ul>
                        </li>
                        <li>管理插斷作業
                            <ul>
                                <li>記憶體管理器發生分頁錯誤時，系統以分頁插斷來處理分頁的載入與置換事宜
                                </li>
                                <li>工作所配置的CPU時間配額終了
                                </li>
                                <li>行程內部事件，例如輸出入插斷 (I/O Interrupt)
                                </li>
                                <li>算術運算也會觸發內部插斷 (Internal Interrupt)<br>(同步插斷(Synchronous Interrupt) )                                </li>
                            </ul>
                        </li>
                    </ul>
                </li>
                
            </ul>
            <h4>行程管理</h4>
            <ul>
                <li>系統可能因眾多行程競相追逐少數資源而停擺</li>
                <li>在缺乏行程同步 (Process Synchronization) 的情況下，可能會發生兩種極端的症狀
                    <ul>
                        <li><span>死結 (Deadlock)</span> 
                        </li>
                        <li><span>飢餓 (Starvation)</span>
                        </li>
                    </ul>
                </li>
                <li>活結 (Livelock)
                    <ul>
                        <li>活結和死結一樣沒有生產力，區別在於死結的症狀是空等，活鎖則是瞎忙</li>
                    </ul>
                </li>
                <li>死結 (Deadlock)
                    <ul>
                        <li><span>系統的整體效能會變得非常低落</span>
                        </li>
                        <li>成因通常涉及無法共用 (Nonsharable) 又不能強占 (Nonpreemptable) 的資源
                        </li>
                        <li>以<span>有向圖(Directed Graph)</span>表現系統資源的配置狀況</li>
                    </ul>
                </li>
                <li>鎖定 (Locking)
                    <ul>
                        <li>確保資料完整性
                        </li>
                        <li>將相關的資料鎖住，禁止他人存取，可以避免其他行程的資料存取影響目前行程的資料處理作業</li>
                        <li>分成三個等級
                            <ul>
                                <li>鎖定資料庫
                                </li>
                                <li>鎖定資料表
                                </li>
                                <li>鎖定資料紀錄
                                </li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>競爭 (Race)
                    <ul>
                        <li>禁止任何行程鎖定資料紀錄當然有效
                        </li>
                        <li>無法確保資料完整性
                        </li>
                        <li>如果一個行程正在修改中的資料遭其他行程讀取或竄改，將會產生錯誤的計算結果
                        </li>
                        <li>計算結果取決於行程排程
                        </li>
                    </ul>
                </li>
                <li>發生在周邊同作裡的死結
                    <ul>
                        <li>周邊同作 (Spooling)
                            <ul>
                                <li>作業系統以虛擬裝置 (Virtual Device) 加速印表作業的速度
                                </li>
                            </ul>
                        </li>
                        <li>周邊同作器 (Spooler) 
                            <ul>
                                <li>使用者輸出到印表機的資料全部會傳送給同作器，同作器將這些資料暫存起來，等到印表機就緒之後，再依序將資料傳送給印表機列印
                                </li>
                                <li>
                                    列印工作除了必須等待印表機就緒之外，也必等到使用者的印表資料全部輸出之後才會開始

                                </li>
                            </ul>
                        </li>
                        <li>周邊同作可能發生死結，造成印表機卡住，所有的使用者都無法列印
                        </li>
                    </ul>
                </li>
                <li><span>死結或活鎖的條件</span>
                    <ul>
                        <li>互斥 (Mutual Exclusion)
                        </li>
                        <li>把持資源 (Resource Holding)
                        </li>
                        <li>不可強占 (No Preemption)
                        </li>
                        <li>循環等待 (Circular Wait)
                        </li>
                    </ul>
                </li>
                <li>死結模型
                    <ul>
                        <li>利用有向圖為死結建立模型，稱為<span>資源配置圖</span>(Resource Allocation Graph)</li>
                        <li>矩形代表資源
                        </li>
                        <li>橢圓形代表行程
                        </li>
                        <li>從資源指向行程的實線箭頭，表示資源已經成功地配置給行程
                        </li>
                        <li>從行程指向資源的虛線箭頭，表示行程提出配置資源的需求，但是配置尚未完成
                        </li>
                        <img width="600px" src="img/14.PNG">
                        <img width="600px" src="img/15.PNG">
                        <li>(a) 未發生死結
                        </li>
                        <li>(b) 在P3 提出配置R1 的需求後，死結成型了</li>
                        <li>請注意圖中的循環等待</li>
                        <img width="600px" src="img/17.PNG">
                    </ul>

                    
                </li>
                <li><span>死結處置策略</span>
                    <ul>
                        <li>預防 (Prevention)
                            <ul>
                                <li>設法讓死結的四項必要條件不會同時成立</li>
                            </ul>
                        </li>
                        <li>避免 (Avoidance)
                            <ul>
                                <li>當死結可能發生時，設法避免死結發生</li>
                            </ul>
                        </li>
                        <li>偵測 (Detection)
                            <ul>
                                <li>如果死結已經發生，設法找出死結所在，將死結解開</li>
                            </ul>
                        </li>
                        <li>復原 (Recovery)
                            <ul>
                                <li>漸進式的復原</li>
                            </ul>
                        </li>

                    </ul>
                </li>
                <li>預防死結
                    <ul>
                        <li>只要讓死結的四項必要條件無法同時成立，就可以預防死結發生</li>
                        <li>階層順序 (Hierarchical Ordering)
                            <ul>
                                <li>作業系統先依序為各項資源編號</li>
                                <li>規定各行程都必須按照編號的順序配置資源，如此一來就不會形成循環等待
                                </li>
                                <li>編號的順序必須符合絕大多數程式配置資源的順序
                                </li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>避免死結
                    <ul>
                        <li>存在一種資源配置的順序，可以避免死結發生
                        </li>
                        <li>銀行家演算法 (Banker’s Algorithm)
                            <ul>
                                <li>假設銀行的資產是固定的，客戶借貸時必須經過審核
                                </li>
                                <li>運作原理如下：
                                    <ul>
                                        <li>單一客戶貸款金額不可高於銀行總資產</li>
                                        <li>每一位客戶在開戶的時候設定該帳戶的信用額度上限</li>
                                        <li>客戶貸款金額不可超過其信用額度上限</li>
                                        <li>客戶貸款金額的總和不可高於銀行總資產</li>
                                    </ul>
                                </li>
                                <li>審核結果
                                    <ul>
                                        <li>安全狀態 (Safe State)
                                        </li>
                                        <li>不安全狀態 (Unsafe state)
                                        </li>
                                    </ul>
                                </li>
                                <li>銀行家演算法實務上的困難
                                    <ul>
                                        <li>程式進入系統時，必須預先確認所需的資源種類與數量，但大部分的互動式系統都無法做到這一點</li>
                                        <li>各類資源的總量必須保持固定，如果某一部裝置突然發生故障，很可能就會讓系統從安全狀態轉為不安全狀態</li>
                                        <li>執行中的行程數量必須保持固定，然而互動式系統不可能讓行程的數量保持不變</li>
                                        <li>系統在接收到每一個資源配置需求時，都必須執行一次銀行家演算法，成本太高</li>
                                        <li>銀行家演算法對資源的管制太過保守，資源利用率偏低</li>
                                        <li>銀行家演算法讓資源利用率偏低，造成排程的困難。配置多項資源的複雜行程，可能因此發生無限期延宕的問題</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>偵測死結
                    <ul>
                        <li>有向圖可以用於死結的偵測
                            <ul>
                                <li>依照資源配置的狀況建立有向圖
                                </li>
                                <li>找出圖中的迴圈
                                </li>
                                <li>不但可以偵測死結是否已經發生，還可以找出牽涉其中的行程和資源
                                </li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>復原
                    <ul>
                        <li>復原演算法 (Recovery Algorithm) 為了解開死結，會挑選犧牲者 (Victim)
                        </li>
                        <li>被選中的行程將會停止運作，釋回所有的資源。犧牲者的資源被剝奪之後，必須重新開始執行</li>
                        <li>系統挑選犧牲者時，必須考慮下列因素，以降低強迫行程終止對系統造成的衝擊
                            <ul>
                                <li>行程的優先順序
                                </li>
                                <li>行程使用的CPU時間
                                </li>
                                <li>行程的相互關係
                                    </li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>飢餓 (Starvation)
                    <ul>
                        <li>死結是放任行程自由配置資源的結果
                        </li>
                        <li>飢餓則是系統介入管制資源配置的結果:某些運氣特別不好的行程一直在等待，可能永遠也等不到所需的資源

                        </li>
                        <li>哲學家進餐問題 (Dinning Philosophers Problem)</li>
                        <li>解決飢餓問題最好的方法之一，便是時間加級  (Aging)
                        </li>
                        <img width="400px" src="img/16.PNG">
                    </ul>
                </li>
            </ul>
        </div>





    </div>


</body>

</html>